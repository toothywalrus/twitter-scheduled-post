1) Сделать валидацию форм.
2) Сделать авторизацию.
3) Сделать динамические <select> в формах. +

4) Сделать обработчик 'changed'
5) Пофиксить удаление твита после exception, перехват этого exception etc.
6) Добавить удобный datetimepicker с current date by default.
7) починить стили для child items.
8) сделать, чтобы нельзя было добавлять дату раньше текущего момента
9) добавить возможность постить от лица разных аккаунтов твиттера, возможность добавлять новые и т.д. (надо посмотреть на метод GetUser, что он возвращает и понять, нужно ли создавать свою модель)


ПРОБЛЕМА!!!!
после рефреша страницы, соединение с /stream не происходит, если было прервано до этого

поле periodic_tweet надо заполнять во время save. 
проблема: мне надо знать pk перед сейвом. почему?


у нас есть модель Post (tweet, user)
1) теперь мы отмечаем, постил ли такой юзер данную инфу;
2) и, допустим, timedtweet считаем запощенным, если запостили его всем юзерам;
3) точно так же periodictweet запощен, если все юзеры данного set-а запостили у себя его
4) таким образом, проверка на already_posted 

    def is_posted_by_user(tweet_pk, user_pk)

    def is_posted(tweet_pk, timedtweet_pk):
        TimedTweet.



{% for form_id, form_inst in forms %}
        <script type="text/ng-template" id="{{ form_id }}">
            {% include "partials/modal.html" with form=form_inst %}
        </script>
    {% endfor %}




если мы запостили такой-то твит такому-то юзеру, проходим по всем timedtweets и periodictweets 
и смотрим, что если есть такой твит и такой юзер, то помечаем  как отмененный.

тут же отсылаем изменения на клиент

зеленый - твит запощен этому юзеру.
синий - твит в будущем будет запощен этому юзеру
красный, серый перечеркнутый - твит уже постился этим юзером, поэтому отменен

то-есть, мы будем с каждым посылом json насчет timedtweet и periodictweet, отсылать так-же
инфу о том, постился ли такой твит для каждого юзера.

можно просто сериализовать вместо поля users возвращать некую хрень по типу словаря из id
юзеров, и твитил ли он данный твит.

но это всё бред. мы можем просто на клиент передавать таблицу Post.
обновлять её точно так-же, как если бы это было с другими моделями.
и тогда, по этой модели, когда в ней происходят изменения, проходить по 
всем обьектам с юзерами и изменять им метку сразу же.
при этом, если какому-то юзеру мы изменили метку на красную, мы посылаем

tweet(tweet, user):
    проверяем, есть ли такой твит в базе
    если есть, то


Надо проверить, что для этой модели TimedTweet мы запостили
данный твит для всех юзеров из users